**초보자를 위한 파이썬 200제를 기반으로 합니다. (장삼용 지음, 정보문화사 출판)** 

- [1. 입문](#1---)
    + [변수명 만들기](#-------)
    + [자료형 개념 및 출력](#-----------)
    + [if, for, while](#if--for--while)
    + [None](#none)
- [2. 초급](#2---)
    + [연산자의 개념](#-------)
    + [시퀀스 자료에 대한 이해](#-------------)
    + [문자열 및 문자열 포맷팅](#-------------)
    + [함수(함수 인자, 지역 변수와 전역 변수, 함수 리턴)](#------------------------------)
    + [파이썬 모듈과 패키지 이해](#--------------)
    + [파일 열고 닫기](#--------)
    + [클래스 개념](#------)
    + [예외처리](#----)
- [3. 중급](#3---)
    + [사용자 입력](#------)
    + [자료 확인 및 간단한 수학](#--------------)
    + [데이터 타입 변경](#---------)
    + [문자열 연습](#------)
    + [리스트 연습](#------)
    + [사전 연습](#-----)
    + [문자 코드](#-----)
- [4. 응용](#4---)
    + [파일 입출력](#------)
    + [파일 관련 작업 (크기, 삭제 등)](#-------------------)
    + [디렉토리 관련](#-------)
    + [날짜](#--)
    + [URL](#url)
    + [파일 분할 및 압축](#----------)

## 1. 입문
#### 변수명 만들기
변수는 밑줄 문자(_) 혹은 영문자로 시작해야 한다. 
대소문자 구분을 한다. 
**예약어**: if, elif, while, for 등의 함수 정의 혹은 class와 같은 예약어가 있는데 이들은 변수로 사용 할 수 없다. 
`import keyword`를 통하여 파이썬 예약어를 확인 할 수 있다. <br>
**내장함수**: abs 등과 같은 내장 함수를 변수로 사용하게 되면 해당 내장 함수를 사용 할 수 없다. 따라서 변수명을 짓는데 신중해야 한다. <br>
변수에 값을 대입하기 위해서는 "="을 사용한다. 
\#은 주석을 의미한다. 

#### 자료형 개념 및 출력
1. 수치형 자료: 정수형(int), 실수형(float), 복소수형(complex)
	- 정수형: 
		- int(일반적인 정수형): 숫자 그대로 입력
		- bin(2진수): 0b를 입력하고 숫자 입력(e.g., 0b10)
		- oct(8진수): 0o를 입력하고 숫자 입력(e.g., 0o10)
		- hex(16진수): 0x를 입력하고 숫자 입력(e.g., 0x10)
		- long 
<br>
	- 실수형:
		- e: 1.56e3 (= 1.56 \* 10^3) / -0.7e-4 (= -0.7 \* 10^-4)
<br>
	- 복소수형:
		```python
		c1 = 1+7j # 파이썬에서는 허수부를 'j'로 씁니다.
		print(c1.real); print(c1.imag) # 정수부, 허수부 출력
		c2 = complex(2,-3) # 2-3j 를 입력
		```
2. 문자열 자료: '문자' & "문자 구문" / 작은 따옴표와 큰 따옴표 간에는 차이가 있음
3. 리스트 자료: [ ] 안에 임의의 객체를 "순서 있게" 나열한 자료로써 각 요소는 ","로 구분이 된다.
4. 튜플 자료: 리스트와 비슷하지만 요소 값을 변경 할 수 없음 (R에서 factor와 유사한듯)
5. 사전 자료: { } 안에 키:값 이라는 쌍이 구성되어 있는 "순서가 없는" 자료형이다. 각 요소는 ","로 구분이 된다. 사전 자료는 순서가 없기 때문에 인덱싱을 통하여 값에 접근 할 수 없기 때문에 '키'값을 통해 접근 할 수 있다. 

자료 출력
```python
a = 200
list_data = ['a','b','c']
dict_data = {'a':97, 'b':98}

print(a) # 200 반환
print(list_data) # 리스트 전체 반환
print(list_data[0]) # 'a' 반환
print(dict_data['a']) # 키 값을 참조하여 97 반환
```

print에 대한 옵션
```python
print('#',end='') # 다음 출력문에 대하여 줄바꿈(\n)을 하지 않는다는 뜻
print('#')
# 두개의 print를 사용하면 # # 가 연속적으로 한 줄에 출력이 된다. 
```

들여쓰기(indent)
*가장 바깥쪽의 실행코드는 들여쓰기 없이 시작*
***콜론(:) 다음 라인부터 실행되는 코드는 들여쓰기 간격이 "동일"해야 함***

#### if, for, while
**IF 문**

```python
# 조건이 오직 T/F와 같이 이항적일 때
if 조건:
	실행1
else:
	실행2

# 다양한 조건
if 조건1:
	실행1
elif 조건2:
	실행2
else:
	실행3
```
	
**FOR 문**

```python
# 기본
for x in RANGE:
	실행

# for ~ continue ~ break
for in RANGE:
	print(x)
	if x < 3:
		continue
	else:
		break

# 등을 설정함으로써 특정 조건에 한해서 for문을 멈출 수 있다. break는 아예 for 문에서 나오는 것을 의미

# for ~ else
for in RANGE:
	반복 실행 코드
else:
	for 문이 모두 실행되었을 때 실행되는 코드
```

for문의 범위로는 시퀀스 자료형 혹은 반복 가능한 자료형이여야 하며, (1)문자열, (2)리스트 혹은 튜플, (3)사전, (4)range() (5)그 외 반복 가능한 객체 등이 있다. 

```python
# 문자열 범위
str='abcdef'
for c in str:
	print(c)
	
# 리스트 범위
list=[1,2,3,4,5]
for c in list:
	print(c)
	
# 사전을 범위
ascii_codes = {'a':97,'b':98,'c':99}
for c in ascii_codes:
	print(c)

# range() 함수를 범위로 지정
for c in range(10):
	print(c)
```

**WHILE 문**
```python
x = 0
while x < 10:
	x = x+1
	if x < 3:
		continue  # while 구문의 처음으로 이동하여 반복문 계속
	print(x)
	if x > 7:
		break # while 구문을 탈출
```
즉 3 미만 일 경우, while 문의 처음으로 돌아가게 된다. 그러나 if 조건에 의하여 3 <= x <= 5 일 경우, print(x)를 수행한다. 이후 x>7인 경우라면 while문을 종료하게 된다. 

#### None
None이라는 자료는 Types.NoneType이라는 값으로써 값이 존재하지 않는 변수에 대입하여 아무런 선언이 이루어지지 않는 공백의 변수를 만들어낸다. 따라서 해당 값에는 다양한 데이터 타입을 입력 할 수 있다. 
`val=None` 이라고 입력을 한 뒤에 `val`에는 어떠한 값도 선언 할 수 있다. 

## 2. 초급
#### 연산자의 개념
**대입: = 을 사용한다. **
**사칙 연산자 **
```
+: 더하기
-: 빼기
*: 곱하기
/: 나누기
**: 거듭제곱 (2**4 = 2^4)
```

**사칙연산의 우선순위:**
`거듭제곱 > 괄호 > 곱셈/나눗셈 > 덧셈/뺄셈`

**연산자 축약**
```python
a+=1 # a = a+1
a-=5 # a = a-5
a*=2 # a = a*2
a/=4 # a = a/4
```

**관계 & 논리 연산자**
```
<관계 연산자>
==: 같다
!=: 다르다
A < B: B가 A보다 크다
A <= B: B가 A보다 크거나 같다
A > B: A가 B보다 크다
A >= A가 B보다 크거나 같다.

<논리 연산자>
&: AND
|: OR
not A: A의 논리값 반대 (TRUE <-> FALSE)
```

**비트 연산자** ~~뭔가 인적성 문제처럼 보인다.~~
비트 연산의 경우, 비트들 간의 '자릿수'에 맞게 비트별로 연산을 하게 된다. 

```
A&B: A와 B비트 간 and 연산을 수행
A|B: A와 B비트 간 or 연산을 수행
A^B: A와 B비트 간 배타적 논리합 xor 연산을 수행
~A: A의 비트를 반전 시킴 (A의 1의 보수를 만듦; 0 <-> 1)
A >> n: A의 모든 비트를 n만큼 오른쪽으로 시프트
A << n: A의 모든 비트를 n만큼 왼쪽으로 시프트
```

#### 시퀀스 자료에 대한 이해
시퀀스 자료는 어떠한 객체가 순서를 갖고 나열이 되는 것을 말한다. 문자열, 리스트, 튜플이 그러한 시퀀스 자료형이다. 

|특성  |설명  |
|-----|-----|
|1. 인덱싱|인덱스를 통해 해당 값에 접근 할 수 있다. 
||인덱스는 0부터 시작|
|2. 슬라이싱|특정 구간의 값을 취할 수 있다. 
||구간은 인덱스 범위를 정의
|3. 연결   |+ 연산자를 이용하여 두 시퀀스 자료를 연결하여 
||새로운 시퀀스 자료를 형성한다.
|4. 반복   |* 연산자를 이용하여 시퀀스 자료를 여러번 반복하여 
||새로운 시퀀스 자료를 형성한다.
|5. 멤버체크|'in' 키워드를 이용하여 
||특정 값이 시퀀스에 속해 있는지 확인
|6. 크기정보|len()을 활용하여 시퀀스 자료의 크기를 알 수 있다. 
||시퀀스 자료의 크기는 문자열은 문자의 개수 
||리스트와 튜플은 멤버의 개수가 된다. 


**1. 시퀀스 자료 인덱싱**
```python
strdata = "Time is money!"
listdata = [1,2,[1,2,3]]
print(strdata[5]) # i를 반환
print(strdata[-2]) # y를 반환
print(listdata[0]) # 1을 반환
print(listdata[-1]) # [1,2,3]을 반환
print(listdata[2][-1]) #[1,2,3] 중 [3]을 반환
```

**2. 시퀀스 자료 슬라이싱**
`[시작 인덱스: 끝 인덱스: 스텝]`
스텝: default ==1 
```python
strdata="Time is money!"
print(strdata[1:5]) #ime 반환
print(strdata[-3:]) #ey! 반환
print(strdata[:-3]) #Time is mon 반환
print(strdata[::2]) #Tm smny 반환 (0부터 2칸씩 띄어서 슬라이싱)
```
**3. 시퀀스 자료 연결**
자료형이 동일한 두 개의 시퀀스 자료에 한 하여 +로 연결을 할 수 있다. 

**4. 시퀀스 자료 반복**
*를 입력하여 시퀀스 자료를 반복 할 수 있다. 
```
list = [1,2,3]
print(list*3) 
# [1,2,3,1,2,3,1,2,3]
```

**5. 멤버 체크 이해하기(in)**
`<값>in<자료>`를 통하여 해당 값이 들어 있는지 확인한다.
```
listdata = [1,2,3,4]
check = 5 in listdata
print(check)
#FALSE
```

**6. 시퀀스 자료 크기**
`len()`을 이용하여 구할 수 있다. 

#### 문자열 및 문자열 포맷팅
"" / '' / """ """ / 이스케이프 문자를 이용한다. 
""와 ''이 존재하는 이유는 `"~~~ 'AAA' ~~~~"` 혹은 `'~~~"BBB"~~~'` 등을 하나의 긴 문자열로 만들 떄 필요하기 때문이다. 
`""" """`의 경우는 다음과 같은 상황에서 쓸 수 있다.
- """ """ 안에서는 줄바꿈이 허용되기 때문에 블록으로써 문자열을 만들 수 있다.
- 또한 """ """는 주석을 남길 때도 블록으로 줄바꿈을 하며 남길 수 있는 장점이 있다 ==(STATA: /\* */와 같은 형태)==

**이스케이프 문자(escape)**
키보드로 표현하기 어려운 기호를 나타낼 때 사용

|이스케이프|설명|
|--------|---|
|\n| 줄 바꾸기|
|\t| 탭|
|\엔터키|줄 계속(다음 줄로 계속되는 줄이라는 표시 +)
|\\| '\' 키 자체를 의미
|\' 혹은 \"| ' 혹은 " 키 자체를 의미|

**문자열 포맷팅**

|포맷 문자열|설명|
|---|---|
|%s|문자열에 대응
|%c|문자나 기호 한 개에 대응
|%f|실수에 대응
|%d|정수에 대응
|%%|%라는 기호 자체를 표시

```python
from time import sleep
for i in range(100)
	msg = '\r진행률%d%%'%(i+1) # i+1이 %d에 할당
	print(''*len(msg),end='')
	print(msg,end='')
	sleep(0.1)
```
`\r`는 캐리지 리턴을 의미하는 뜻으로써 현재 위치를 나타내는 커서를 화면 맨 앞으로 이동하라는 뜻이다. 


#### 함수(함수 인자, 지역 변수와 전역 변수, 함수 리턴)
```python
# 인자와 리턴 값이 있는 경우
def 함수이름(인자1, 인자2, ...):
	코드 작성
	return 결과값
	
변수 = 함수이름(값1, 값2, ...) # 인자에 매칭
	
# 리턴 값만 있고, 인자는 없는 경우
def 함수이름():
	코드 작성
	return 결과값
	
함수이름()

# 리턴 값은 없고, 인자만 있는 경우
def 함수이름(값1, 값2, ...):
	코드 작성
	return() 혹은 생략
	
함수이름(값1, 값2,...)

# 인자와 리턴값이 없는 함수
def 함수이름():
	코드 작성
	return() 혹은 생략
	
함수이름()
	
	```

함수의 장점은 굳이 재사용의 목적이 아니더라도, 복잡한 알고리즘을 독립적인 영역에서 따로 구현 할 수 있게 되어 소스코드의 가독성을 높일 수 있게 된다. 

**함수인자**
1. 기본인자를 이용하여 값을 전달하는 방법
`함수호출(a,b,c) -> 함수정의(x,y,z)`에 매칭

2. 인자 이름을 이용해 값을 전달하는 방법
`함수호출(y=b,x=a,z=c) -> 함수정의(x,y,z)`에 매칭된다. 

3. 가변 인자 튜플을 이용해 값을 전달하는 방법
4. 미정 키워드 인자 사전을 이용해 값을 전달하는 방법

```python
def func1(*args):
	print(args)

# 인자의 개수가 불명확한 경우 *args와 같이 *를 사용하여 활용할 경우 함수 내부에서 '튜블'로 처리가 된다. 
	
def func2(width, height, **kwargs):
	print(kwargs)
	
# 키워드 인자가 불명확한 경우가 있을 경우 **를 사용하면 함수 내부에서 '사전'으로 처리하게 된다. 

func1(3,5,1,5) # 튜플로 정의되었기 때문에 (3,5,1,5)라는 튜플을 반환한다. 
func2(10,20) # width, height만 입력이 되었기 떄문에 빈 사전이 반환된다. 

func2(10,20,depth=50,color='blue') # depth와 color에 대한 정보가 담긴 ['depth':50,'color':'blue']라는 사전이 포함되어 출력된다. 
```

**전역변수와 지역변수**
전역변수: 코드 전반에 걸쳐 유효한 변수
지역변수: 정의되는 함수 내에서만 유효한 변수 (함수의 인자로 선언되는 변수는 함수 내에서만 유효한 지역변수이다)

**함수 리턴값(return)**
함수가 수행되고 나면 그 결과를 리턴하고 종료하는 경우가 많다. 이때 return 키워드를 이용하여 값을 리턴하고 함수를 종료한다. 리턴값이 여러개일 경우 튜플로 리턴값을 만들어 리턴을 하면 된다. 


#### 파이썬 모듈과 패키지 이해
모듈은 흔히 말하는 라이브러리의 개념과 일치한다.
패키지 모듈은 '계측적인 디렉토리' 형태로 구성한 **파이썬 패키지**이다. 디렉토리를 파이썬 패키지로 인식을 하려면 계측적으로 이루어져 있는 각 디렉토리마다 \_\_init\_\_.py라는 이름의 파이썬 파일이 있어야 한다. 해당 py의 내용은 간단한 내용만 있어도 된다. 

다시 말하여, 모듈이 계층적으로 있을 경우 이들을 구분하기 위한 요소로서 \_\_init\_\_.py가 있고 이들이 일종의 구분을 하는 역할을 한다. 

**모듈 import**
`import 모듈이름` 혹은 `import 패키지이름.모듈이름`을 활용한다. 
`from 모듈이름 import 함수이름` 혹은 `from 패키지 이름 import 모듈이름`을 통하여 패키지.모듈.함수 등의 nested된 형태를 보다 수월하게 import할 수 있다. 

`import 모듈명 as 별명`을 지어 모듈명.함수를 사용 할 때 짧게 쓸 수 있다. 

#### 파일 열고 닫기
`open(파일명, 모드)`를 사용한다.`close()`를 사용하여 파일을 닫는다.
```python
f1 = open('text.txt','r')
f2 = open('picture.jpg','rb')
f1.close()
f2.close()
```

|모드|설명|
|---|---|
|r 또는 rt|텍스트 모드로 읽기|
|w 또는 wt|텍스트 모드로 쓰기|
|a 또는 at|텍스트 모드로 파일 마지막에 추가|
|rb|바이너리 모드로 읽기|
|wb|바이너리 모드로 쓰기|
|ab|바이너리 모드로 파일 마지막에 추가하기|

*txt의 경우 텍스트 모드이지만, jpg 등의 경우는 바이너리 모드를 의미한다.*

#### 클래스 개념
*코딩책과 함께보는 코딩개념 사전 - 김현정 - 궁리 출판사 를 참고하도록 한다*

```python
class 클래스 이름:
	# 클래스 멤버 정의
	color = 1
	# 클래스 메소드 정의
		def sayHello(self):    #sayHello는 클래스를 참고(self)
			print('Hello')
	
obj = 클래스이름()

obj.클래스멤버 #인스턴스 객체(obj)의 클래스 멤버
obj.클래스메소드 #인스턴스 객체(obj)의 클래스 메소드
```
`self.var`은 클래스 메소드 내에서 var을 참조하는 것을 의미
`obj.var`은 인스턴스 객체(obj) 내에서 var을 참조하는 것을 의미


**클래스 소멸자**
\_\_del\_\_(self):를 사용할 경우, \_\_init\_\_를 사용한 클래스 생성자와 반대로 해당 클래스의 인스턴스 객체를 삭제한다. 

#### 예외처리
**기본형태**
```python
try:
	print('안녕')
	print(var)
except:
	print('예외가 발생')
```
오류가 발생할 가능성이 큰 부분에 대하여 try~except 문을 실시하여, 오류가 발생했을 경우 단순히 stop 하는 것이 아니라 except 문으로 넘어가서 해당 작업을 수행하게 된다. 

**try ~ except ~ else 구문**
```python
try:
	print('안녕')
	print(var)
except:
	print('예외가 발생')
else:   
	print('예외가 발생하지 않았다')
```
else 구문까지 추가하는 경우 try 문이 모두 TRUE일 경우 else 구문을 반환한다.

** try ~ except ~ finally 구문**
```python
try:
	print('안녕')
	print(var)
except:
	print('예외가 발생')
finally:  
	print('무조건 수행')
```
try~except의 구문과 관계 없이 무조건 finally 이하 구문을 수행을 하게 된다. 

** try ~ except Exception as 구문**
```python
try:
	print('안녕')
	print(var)
except Exception as e:
	print('e')
```
에러가 발생할 경우 해당 error에 대한 msg를 e로 넘길 수 있는 구문이다. 

** try ~ except 특정 상황 예외 구문**
```python
import time
count =1

try:
	while TRUE:
		print(count)
		count +=1
		time.sleep(0.5)
except KeyboardInterrupt: 
# Ctrl+C를 입력하게 되면 사용자에 의하여 코드가 중단된다. 
	print('사용자가 중단함')
```
해당 프로그램의 경우 0.5초씩 count가 증가하게 되는데, 이는 무한 반복이기 때문에 중간에 사용자가 break를 하지 않는 이상 계속 흘러간다. 따라서 이 경우 `KeyboardInterrupt`라는 구문을 추가하여 프로그램을 멈출 수 있다. 

    
## 3. 중급
#### 사용자 입력
#### 자료 확인 및 간단한 수학
#### 데이터 타입 변경
#### 문자열 연습
#### 리스트 연습
#### 사전 연습
#### 문자 코드
     

## 4. 응용
#### 파일 입출력
#### 파일 관련 작업 (크기, 삭제 등)
#### 디렉토리 관련
#### 날짜
#### URL
#### 파일 분할 및 압축
